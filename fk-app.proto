syntax = "proto3";
package fk_app;

// QueryType provides a way of determining the incoming type of a message. In
// some cases simply looking at which "sub-message" is populated would work but the
// QueryType is useful for situations where the query sub-message is empty.

enum QueryType {
  QUERY_NONE = 0;
  QUERY_CAPABILITIES = 1;
  QUERY_CONFIGURE_SENSOR = 2;
  QUERY_LIVE_DATA_POLL = 7;
  QUERY_SCHEDULES = 8;
  QUERY_CONFIGUE_SCHEDULES = 9;
  QUERY_FILES = 10;
  QUERY_DOWNLOAD_FILE = 11;
  QUERY_ERASE_FILE = 12;
  QUERY_RESET = 13;
  QUERY_NETWORK_SETTINGS = 14;
  QUERY_CONFIGURE_NETWORK_SETTINGS = 15;
  QUERY_IDENTITY = 16;
  QUERY_CONFIGURE_IDENTITY = 17;
  QUERY_STATUS = 18;
  QUERY_MODULE = 19;
  QUERY_METADATA = 20;
  QUERY_FORMAT = 21;
  QUERY_GET_READINGS = 22;
  QUERY_TAKE_READINGS = 23;
  QUERY_RECORDING_CONTROL = 24;
  QUERY_CONFIGURE = 25;
}

// ReplyType serves a similar purpose. In general situations this isn't as
// useful as the QueryType, but may be useful if there's ever any kind of
// asynchronous communications where replies can come back out of order.

enum ReplyType {
  REPLY_NONE = 0;
  REPLY_SUCCESS = 1;
  REPLY_BUSY = 2;
  REPLY_ERROR = 3;
  REPLY_CAPABILITIES = 4;
  REPLY_LIVE_DATA_POLL = 8;
  REPLY_SCHEDULES = 9;
  REPLY_FILES = 10;
  REPLY_DOWNLOAD_FILE = 11;
  REPLY_RESET = 12;
  REPLY_NETWORK_SETTINGS = 13;
  REPLY_IDENTITY = 14;
  REPLY_STATUS = 15;
  REPLY_MODULE = 16;
  REPLY_METADATA = 17;
  REPLY_READINGS = 18;
}

enum DownloadFlags {
  DOWNLOAD_FLAG_NONE = 0;
  DOWNLOAD_FLAG_METADATA_PREPEND = 1;
  DOWNLOAD_FLAG_METADATA_ONLY = 2;
}

enum ModuleFlags {
  MODULE_FLAG_NONE = 0;
  MODULE_FLAG_INTERNAL = 1;
}

enum SensorFlags {
  SENSOR_FLAG_NONE = 0;
}

// Querying information about the device, what it's capable of. Typically the
// first message that will be sent to a device.

message QueryCapabilities {
  uint32 version = 1;
  uint32 callerTime = 2;
}

// Information about an individual sensor attached to the device. Temerature,
// Depth, Conductivity, Humidity, etc...

message LiveValue {
  bool valid = 1;
  float value = 2;
}

message SensorCapabilities {
  uint32 number = 1;
  uint32 module = 2;
  string name = 3;
  uint32 frequency = 4;
  string unitOfMeasure = 5;

  // v2
  string path = 6;
  uint32 flags = 7;
  LiveValue value = 8;
}

message ModuleCapabilities {
  uint32 position = 1;
  string name = 2;
  repeated SensorCapabilities sensors = 3;

  // v2
  string path = 4;
  uint32 flags = 5;
  bytes id = 6;
}

message Capabilities {
  uint32 version = 1;
  bytes deviceId = 2;
  string name = 3;
  repeated ModuleCapabilities modules = 4;
  repeated SensorCapabilities sensors = 5;
}

message NetworkInfo {
  string ssid = 1;
  string password = 2;
}

message NetworkSettings {
  int32 createAccessPoint = 1;
  repeated NetworkInfo networks = 2;
}

message Identity {
  string device = 1;
  string stream = 2;
  bytes deviceId = 3;
  string firmware = 4;
  string build = 5;

  // v2
  string name = 6;
  bytes generation = 7;
}

// Configuring a particular sensor on the device. Some sensors may require
// sub-messages to be defined here. It will be interesting to see how this has to
// change to facilitate dynamic sensor configuration.

message ConfigureSensorQuery {
  uint32 id = 1;
  uint32 frequency = 2;
}

// Querying for a list of data sets that the device has in memory.

message LiveDataPoll {
  uint32 interval = 1;
}

message LiveDataSample {
  uint32 sensor = 1;
  uint64 time = 2;
  float value = 3;
}

message LiveData {
  repeated LiveDataSample samples = 1;
}

// Files

message File {
  uint32 id = 1;
  uint64 time = 2;
  uint64 size = 3;
  uint32 version = 4;
  string name = 5;
  uint64 maximum = 6;
}

message Files {
  repeated File files = 1;
}

message DownloadFile {
  uint32 id = 1;
  uint32 offset = 2;
  uint32 length = 3;
  uint32 flags = 4;
}

message EraseFile {
  uint32 id = 1;
}

message FileData {
  uint32 offset = 1;
  bytes data = 2;
  uint32 size = 3;
  uint32 hash = 4;
  uint32 version = 5;
  uint32 id = 6;
}

message DeviceStatus {
  uint32 uptime = 1;
  float batteryPercentage = 2;
  float batteryVoltage = 3;
  uint32 gpsHasFix = 4;
  uint32 gpsSatellites = 5;
}

message QueryModule {
  uint32 id = 1;
  uint32 address = 2;
  bytes message = 3;
}

message ModuleReply {
  uint32 id = 1;
  uint32 address = 2;
  bytes message = 3;
}

// Top level messages exchanged over the wire.

message WireMessageQuery {
  QueryType type = 1;
  QueryCapabilities queryCapabilities = 2;
  ConfigureSensorQuery configureSensor = 3;
  LiveDataPoll liveDataPoll = 8;
  // Schedules newSchedules = 9;
  DownloadFile downloadFile = 10;
  EraseFile eraseFile = 11;
  NetworkSettings networkSettings = 12;
  Identity identity = 13;
  QueryModule module = 14;
}

message Error {
  string message = 1;
  uint32 delay = 2;
}

message WireMessageReply {
  ReplyType type = 1;
  repeated Error errors = 2;
  Capabilities capabilities = 3;
  LiveData liveData = 6;
  // Schedules schedules = 7;
  Files files = 8;
  FileData fileData = 9;
  NetworkSettings networkSettings = 10;
  Identity identity = 11;
  DeviceStatus status = 12;
  ModuleReply module = 13;
}

/**************************************************************************************************/

message Schedule {
  bytes cron = 1;
  uint32 seconds = 2;
}

message Schedules {
  Schedule readings = 1;
}

message HardwareStatus {
}

message GpsStatus {
  uint32 enabled = 7;
  uint32 fix = 1;
  uint64 time = 2;
  uint32 satellites = 3;
  float longitude = 4;
  float latitude = 5;
  float altitude = 6;
}

message MemoryStatus {
  uint32 sramAvailable = 1;
  uint32 programFlashAvailable = 2;
  uint32 extendedMemoryAvailable = 3;
  uint32 dataMemoryInstalled = 4;
  uint32 dataMemoryUsed = 5;
  float dataMemoryConsumption = 6;
}

message BatteryStatus {
  uint32 voltage = 1;
  uint32 percentage = 2;
}

message PowerStatus {
  BatteryStatus battery = 1;
}

message Status {
  uint32 version = 1;
  uint32 uptime = 2;
  Identity identity = 3;
  HardwareStatus hardware = 4;
  PowerStatus power = 5;
  MemoryStatus memory = 6;
  GpsStatus gps = 7;
  Schedules schedules = 8;
  Recording recording = 9;
  NetworkSettings network = 10;
}

message Range {
  uint32 start = 1;
  uint32 end = 2;
}

message DownloadQuery {
  uint32 stream = 1;
  repeated Range ranges = 3;
  repeated uint32 blocks = 4;
}

message Recording {
  bool modifying = 1;
  bool enabled = 2;
  uint64 started_time = 3;
}

message HttpQuery {
  QueryType type = 1;
  Identity identity = 2;
  Recording recording = 3;
  Schedules schedules = 4;
  uint32 flags = 5;
}

message DataStream {
  uint32 id = 1;
  uint64 time = 2;
  uint64 size = 3;
  uint32 version = 4;
  uint64 block = 5;
  bytes hash = 6;
  string name = 7;
  string path = 8;
}

message LiveSensorReading {
  SensorCapabilities sensor = 1;
  float value = 2;
}

message LiveModuleReadings {
  ModuleCapabilities module = 1;
  repeated LiveSensorReading readings = 2;
}

message LiveReadings {
  uint64 time = 1;
  repeated LiveModuleReadings modules = 2;
}

message HttpReply {
  ReplyType type = 1;
  repeated Error errors = 2;
  Status status = 3;
  NetworkSettings networkSettings = 4;
  repeated ModuleCapabilities modules = 5;
  repeated DataStream streams = 6;
  repeated LiveReadings liveReadings = 7;
}
