syntax = "proto3";
package fk_app;

// QueryType provides a way of determining the incoming type of a message. In
// some cases simply looking at which "sub-message" is populated would work but the
// QueryType is useful for situations where the query sub-message is empty.

enum QueryType {
  QUERY_NONE = 0;
  QUERY_CAPABILITIES = 1;
  QUERY_CONFIGURE_SENSOR = 2;
  QUERY_DATA_SETS = 3;
  QUERY_DATA_SET = 4;
  QUERY_DOWNLOAD_DATA_SET = 5;
  QUERY_ERASE_DATA_SET = 6;
  QUERY_LIVE_DATA_POLL = 7;
  QUERY_SCHEDULES = 8;
  QUERY_CONFIGUE_SCHEDULES = 9;
}

// ReplyType serves a similar purpose. In general situations this isn't as
// useful as the QueryType, but may be useful if there's ever any kind of
// asynchronous communications where replies can come back out of order.

enum ReplyType {
  REPLY_NONE = 0;
  REPLY_SUCCESS = 1;
  REPLY_ERROR = 2;
  REPLY_CAPABILITIES = 3;
  REPLY_DATA_SETS = 4;
  REPLY_DATA_SET = 5;
  REPLY_DOWNLOAD_DATA_SET = 6;
  REPLY_LIVE_DATA_POLL = 7;
  REPLY_SCHEDULES = 8;
}

// Querying information about the device, what it's capable of. Typically the
// first message that will be sent to a device.

message QueryCapabilities {
  uint32 version = 1;
  uint32 callerTime = 2;
}

message ModuleCapabilities {
  uint32 id = 1;
  string name = 2;
}

// Information about an individual sensor attached to the device. Temerature,
// Depth, Conductivity, Humidity, etc...

message SensorCapabilities {
  uint32 id = 1;
  uint32 module = 2;
  string name = 3;
  uint32 frequency = 4;
  string unitOfMeasure = 5;
}

message Capabilities {
  uint32 version = 1;
  string name = 2;
  repeated ModuleCapabilities modules = 3;
  repeated SensorCapabilities sensors = 4;
}

message TimeSpec {
  int32 fixed = 1;
  int32 interval = 2;
  int32 offset = 3;
}

message Schedule {
  TimeSpec second = 1;
  TimeSpec minute = 2;
  TimeSpec hour = 3;
  TimeSpec day = 4;
}

message Schedules {
  Schedule readings = 1;
  Schedule transmission = 2;
  Schedule status = 3;
  Schedule location = 4;
}

// Configuring a particular sensor on the device. Some sensors may require
// sub-messages to be defined here. It will be interesting to see how this has to
// change to facilitate dynamic sensor configuration.

message ConfigureSensorQuery {
  uint32 id = 1;
  uint32 frequency = 2;
}

// Querying for a list of data sets that the device has in memory.

message QueryDataSets {
}

message DataSet {
  uint32 id = 1;
  uint32 sensor = 2;
  uint64 time = 3;
  uint32 size = 4;
  uint32 pages = 5;
  uint32 hash = 6;
  string name = 7;
}

// TODO: Paging?
message DataSets {
  repeated DataSet dataSets = 1;
}

// Download a data set.

message DownloadDataSet {
  uint32 id = 1;
  uint32 page = 2;
}

// Datasets can be stored in multiple ways depending on the need:
// 1) Values at a certain fixed frequency.
// 2) Individual samples taken at certain times.
// We'll need to discuss a raw format possibly too for situations where the
// Protobuf overhead is too great?

message Sample {
  uint64 time = 1;
  float value = 2;
}

message DataSetData {
  uint64 time = 1;
  uint32 page = 2;
  uint32 sensor = 3;
  repeated Sample samples = 4;
  repeated float floats = 5;
  bytes data = 6;
  uint32 hash = 7;
}

message LiveDataPoll {
  uint32 interval = 1;
}

message LiveDataSample {
  uint32 sensor = 1;
  uint64 time = 2;
  float value = 3;
}

message LiveData {
  repeated LiveDataSample samples = 1;
}

// Query a data set.

message QueryDataSet {
  uint32 id = 1;
}

// Erase a data set.

message EraseDataSet {
  uint32 id = 1;
}

// Top level messages exchanged over the wire.

message WireMessageQuery {
  QueryType type = 1;
  QueryCapabilities queryCapabilities = 2;
  ConfigureSensorQuery configureSensor = 3;
  QueryDataSets queryDataSets = 4;
  QueryDataSet queryDataSet = 5;
  DownloadDataSet downloadDataSet = 6;
  EraseDataSet eraseDataSet = 7;
  LiveDataPoll liveDataPoll = 8;
  Schedules newSchedules = 9;
}

message Error {
  string message = 1;
}

message WireMessageReply {
  ReplyType type = 1;
  repeated Error errors = 2;
  Capabilities capabilities = 3;
  DataSets dataSets = 4;
  DataSetData dataSetData = 5;
  LiveData liveData = 6;
  Schedules schedules = 7;
}
